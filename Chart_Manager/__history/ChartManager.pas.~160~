unit ChartManager;
(*
  走势图管理单元
*)

interface

uses
  Series, Classes;

type

  //折线图-三线
  ThreeSeriesChart = record
    ValueSeries1: TFastLineSeries;
    ValueSeries2: TFastLineSeries;
    ConstantSeries: TFastLineSeries;
  end;

  //折线图-双线
  TwoSeriesChart = class
    ValueSeries1: TFastLineSeries;
    ConstantSeries: TFastLineSeries;
  end;

  //提供series数据更新功能，并且维护一个Series表，里面缓存series数据
  TSeriesManager = class
  private
    SeriesList: TStringList;
    CacheSize: Integer;
  public
    constructor Create(const ACacheSize: Integer = 3);
    procedure AddSeries(const Akey: string; Aseries: TObject);
    procedure RemoveSeries(const Akey: string = '');
    function GetCurrentSeries(): Pointer;
    procedure SetCurrentSeries(const Akey: string);
    procedure AddDataToCurrentSeries(Adata: TObject);
    function find(const Akey:string): Integer;
    procedure addOneTick(Akey:string);
    destructor Destroy();
  end;

var
  AvaibleChartId: string;
//  TwoSeriesManager = Class(SeriesManager)
//    procedure AddDataToCurrentSeries(Adata:TwoSeriesChart);
//  end;

implementation

constructor TSeriesManager.Create(const ACacheSize: Integer = 3);
begin
  inherited Create;
  SeriesList := TStringList.Create;
  CacheSize := ACacheSize;
end;

procedure TSeriesManager.AddSeries(const Akey: string; Aseries: TObject);
begin
  if (SeriesList.Count = CacheSize) then
  begin
    SeriesList.Delete(CacheSize - 1);
  end;
  SeriesList.AddObject(Akey, Aseries);

end;

procedure TSeriesManager.RemoveSeries(const Akey: string = '');
var
  index: Integer;
begin
  if SeriesList.Count = 0 then
  begin
    Exit;
  end;

  if Akey = '' then
  begin
    SeriesList.Delete(SeriesList.Count - 1);
  end
  else
  begin
    index := SeriesList.IndexOf(Akey);
    SeriesList.Delete(index);
  end;

end;

function TSeriesManager.GetCurrentSeries(): Pointer;
begin
  Result := SeriesList.Objects[0];
end;

procedure TSeriesManager.SetCurrentSeries(const Akey: string);
var
  index: Integer;
begin
  index := SeriesList.IndexOf(Akey);
  if(index >= 0)then
  begin
    SeriesList.Move(index, 0);
  end;

end;

procedure TSeriesManager.AddDataToCurrentSeries(Adata: TObject);
begin
  SeriesList.Objects[0] := Adata;
end;

function TSeriesManager.find(const Akey:string): Integer;
begin
  Result := SeriesList.IndexOf(Akey);
end;

destructor TSeriesManager.Destroy();
var
  pobj: ^TObject;
  I: Integer;
begin
  for I := 0 to SeriesList.Count do
  begin
    SeriesList.Objects[0];
    pobj^ := SeriesList.Objects[I];
    pobj.Free;
  end;
  SeriesList.Free;

  inherited Destroy;
end;

end.

